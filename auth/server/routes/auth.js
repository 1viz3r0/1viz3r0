const express = require('express');
const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const User = require('../models/User');
const Session = require('../models/Session');
const { generateOTP, getOTPExpiry, verifyOTP } = require('../utils/otp');
const { sendOTPEmail } = require('../utils/email');
const { sendOTPSMS, verifyOTPSMS } = require('../utils/sms');
const { validateEmail, validatePassword, validatePhone } = require('../utils/validation');
const { protect } = require('../middleware/auth');

const router = express.Router();

// Generate JWT token
const generateToken = (userId) => {
  return jwt.sign({ id: userId }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRE
  });
};

// POST /api/auth/register
router.post('/register', async (req, res, next) => {
  try {
    const { name, email, phone, password } = req.body;

    // Validate inputs
    const emailValidation = validateEmail(email);
    if (!emailValidation.valid) {
      return res.status(400).json({ success: false, message: emailValidation.message });
    }

    const passwordValidation = validatePassword(password);
    if (!passwordValidation.valid) {
      return res.status(400).json({ success: false, message: passwordValidation.message });
    }

    const phoneValidation = validatePhone(phone);
    if (!phoneValidation.valid) {
      return res.status(400).json({ success: false, message: phoneValidation.message });
    }

    // Check if user already exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ success: false, message: 'Email already registered' });
    }

    // Generate session ID
    const sessionId = crypto.randomBytes(32).toString('hex');

    // Generate OTP for email (SMS OTP is generated by Twilio Verify)
    const emailOTP = generateOTP();

    // Create session with user data
    // Note: mobileOTP.code is not stored since Twilio Verify generates and manages it
    await Session.create({
      sessionId,
      userData: { name, email, phone, password },
      emailOTP: {
        code: emailOTP,
        expiresAt: getOTPExpiry(),
        verified: false
      },
      mobileOTP: {
        verified: false,
        attempts: 0
        // Note: OTP code is not stored - Twilio Verify manages it
      }
    });

    // Send OTPs
    // Note: Twilio Verify generates its own OTP, so we don't pass mobileOTP
    const emailResult = await sendOTPEmail(email, emailOTP);
    const smsResult = await sendOTPSMS(phone);

    // Log email result for debugging
    if (!emailResult.success) {
      console.error('‚ùå Email sending failed:', emailResult.error);
      // In development, log OTP to console
      if (process.env.NODE_ENV === 'development') {
        console.log('üìß [DEV MODE] Email OTP for', email, ':', emailOTP);
      }
    } else {
      console.log('‚úÖ Email sent successfully:', emailResult.messageId);
    }

    // Log SMS result for debugging
    if (!smsResult.success) {
      console.error('‚ùå SMS sending failed:', smsResult.error);
      console.error('   Error code:', smsResult.code);
    } else {
      console.log('‚úÖ SMS sent successfully via Twilio Verify:', smsResult.sid);
      console.log('   Status:', smsResult.status);
      // Note: With Twilio Verify, OTP is managed by Twilio - we don't have access to it
    }

    console.log(`Registration initiated for ${email}`);

    // Check if email was sent successfully
    if (!emailResult.success) {
      return res.status(500).json({
        success: false,
        message: 'Failed to send email OTP. Please check your email configuration or try again.',
        error: process.env.NODE_ENV === 'development' ? emailResult.error : undefined,
        // In development, include OTP for testing
        ...(process.env.NODE_ENV === 'development' && { devOTP: emailOTP })
      });
    }

    res.status(200).json({
      success: true,
      sessionId,
      requiresOTP: true,
      message: 'OTPs sent to email and phone',
      // In development, include OTPs for testing
      ...(process.env.NODE_ENV === 'development' && { 
        devEmailOTP: emailOTP,
        // SMS OTP is handled by Twilio Verify and is not available here
      })
    });
  } catch (error) {
    next(error);
  }
});

// POST /api/auth/verify-email-otp
router.post('/verify-email-otp', async (req, res, next) => {
  try {
    const { sessionId, otp } = req.body;

    if (!sessionId || !otp) {
      return res.status(400).json({ success: false, message: 'Session ID and OTP required' });
    }

    const session = await Session.findOne({ sessionId });
    if (!session) {
      return res.status(404).json({ success: false, message: 'Session not found or expired' });
    }

    // Check attempts
    if (session.emailOTP.attempts >= 5) {
      return res.status(429).json({ success: false, message: 'Too many attempts. Please request a new OTP.' });
    }

    // Verify OTP
    const verification = verifyOTP(session.emailOTP.code, otp, session.emailOTP.expiresAt);
    
    if (!verification.valid) {
      session.emailOTP.attempts += 1;
      await session.save();
      console.log('‚ùå Email OTP verification failed:', verification.message, 'Attempts:', session.emailOTP.attempts);
      return res.status(400).json({ success: false, message: verification.message });
    }

    // Mark email as verified
    session.emailOTP.verified = true;
    await session.save();

    console.log('‚úÖ Email OTP verified successfully for session:', sessionId);

    res.status(200).json({
      success: true,
      message: 'Email verified successfully'
    });
  } catch (error) {
    next(error);
  }
});

// POST /api/auth/verify-mobile-otp
router.post('/verify-mobile-otp', async (req, res, next) => {
  try {
    const { sessionId, otp } = req.body;

    if (!sessionId || !otp) {
      return res.status(400).json({ success: false, message: 'Session ID and OTP required' });
    }

    const session = await Session.findOne({ sessionId });
    if (!session) {
      return res.status(404).json({ success: false, message: 'Session not found or expired' });
    }

    // Check if email was verified first
    if (!session.emailOTP.verified) {
      return res.status(400).json({ success: false, message: 'Please verify email first' });
    }

    // Verify OTP using Twilio Verify API
    // Note: With Twilio Verify, verification is handled by Twilio, not stored in our session
    const phone = session.userData.phone;
    console.log('üîç Verifying mobile OTP for phone:', phone, 'Session:', sessionId);
    const twilioVerification = await verifyOTPSMS(phone, otp);
    console.log('üì± Twilio verification result:', twilioVerification);
    
    if (!twilioVerification.success) {
      console.error('‚ùå Mobile OTP verification failed:', twilioVerification.error);
      return res.status(400).json({ 
        success: false, 
        message: twilioVerification.error || 'Failed to verify OTP' 
      });
    }
    
    if (!twilioVerification.valid) {
      console.error('‚ùå Mobile OTP is invalid');
      return res.status(400).json({ 
        success: false, 
        message: 'Invalid verification code. Please try again.' 
      });
    }
    
    console.log('‚úÖ Mobile OTP verified successfully');

    // Create user
    const user = await User.create({
      name: session.userData.name,
      email: session.userData.email,
      phone: session.userData.phone,
      password: session.userData.password,
      isEmailVerified: true,
      isPhoneVerified: true
    });

    // Delete session
    await Session.deleteOne({ sessionId });

    // Generate token
    const token = generateToken(user._id);

    res.status(201).json({
      success: true,
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        phone: user.phone
      }
    });
  } catch (error) {
    next(error);
  }
});

// POST /api/auth/resend-otp
router.post('/resend-otp', async (req, res, next) => {
  try {
    const { sessionId, type } = req.body;

    if (!sessionId || !type) {
      return res.status(400).json({ success: false, message: 'Session ID and type required' });
    }

    if (!['email', 'mobile'].includes(type)) {
      return res.status(400).json({ success: false, message: 'Invalid type' });
    }

    const session = await Session.findOne({ sessionId });
    if (!session) {
      return res.status(404).json({ success: false, message: 'Session not found or expired' });
    }

    // Generate new OTP
    const newOTP = generateOTP();

    if (type === 'email') {
      session.emailOTP = {
        code: newOTP,
        expiresAt: getOTPExpiry(),
        verified: false,
        attempts: 0
      };
      await session.save();
      const emailResult = await sendOTPEmail(session.userData.email, newOTP);
      
      if (!emailResult.success) {
        console.error('‚ùå Email resend failed:', emailResult.error);
        if (process.env.NODE_ENV === 'development') {
          console.log('üìß [DEV MODE] Resend Email OTP for', session.userData.email, ':', newOTP);
        }
        return res.status(500).json({
          success: false,
          message: 'Failed to send email OTP. Please check your email configuration.',
          error: process.env.NODE_ENV === 'development' ? emailResult.error : undefined,
          ...(process.env.NODE_ENV === 'development' && { devOTP: newOTP })
        });
      }
      
      console.log('‚úÖ Email OTP resent successfully');
    } else {
      // For mobile, use Twilio Verify (OTP is generated by Twilio)
      // Note: With Twilio Verify, we don't store OTP in session
      if (!session.mobileOTP) {
        session.mobileOTP = {
          verified: false,
          attempts: 0
        };
      }
      await session.save();
      
      const smsResult = await sendOTPSMS(session.userData.phone);
      
      if (!smsResult.success) {
        console.error('‚ùå SMS resend failed:', smsResult.error);
        console.error('   Error code:', smsResult.code);
        return res.status(500).json({
          success: false,
          message: 'Failed to send SMS OTP. Please check your SMS configuration.',
          error: process.env.NODE_ENV === 'development' ? smsResult.error : undefined
        });
      }
      
      console.log('‚úÖ SMS OTP resent successfully via Twilio Verify');
    }

    res.status(200).json({
      success: true,
      message: `New OTP sent to ${type}`,
      // Note: With Twilio Verify for SMS, OTP is not available (generated by Twilio)
      ...(process.env.NODE_ENV === 'development' && type === 'email' && { devOTP: newOTP })
    });
  } catch (error) {
    next(error);
  }
});

// POST /api/auth/login
router.post('/login', async (req, res, next) => {
  try {
    const { email, password } = req.body;

    // Validate
    const emailValidation = validateEmail(email);
    if (!emailValidation.valid) {
      return res.status(400).json({ success: false, message: emailValidation.message });
    }

    if (!password) {
      return res.status(400).json({ success: false, message: 'Password is required' });
    }

    // Find user (include password field)
    const user = await User.findOne({ email }).select('+password');
    if (!user) {
      return res.status(401).json({ success: false, message: 'Invalid credentials' });
    }

    // Check password
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      return res.status(401).json({ success: false, message: 'Invalid credentials' });
    }

    // Generate token
    const token = generateToken(user._id);

    res.status(200).json({
      success: true,
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        phone: user.phone
      }
    });
  } catch (error) {
    next(error);
  }
});

// POST /api/auth/google
router.post('/google', async (req, res, next) => {
  try {
    const { idToken } = req.body;

    if (!idToken) {
      return res.status(400).json({ success: false, message: 'ID token required' });
    }

    // Decode and verify Google ID token
    let payload;
    try {
      // Try to use google-auth-library if available
      try {
        const { OAuth2Client } = require('google-auth-library');
        const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);
        const ticket = await client.verifyIdToken({
          idToken: idToken,
          audience: process.env.GOOGLE_CLIENT_ID,
        });
        payload = ticket.getPayload();
      } catch (googleAuthError) {
        // Fallback: Decode JWT without verification (less secure but works)
        // Split the token into parts
        const parts = idToken.split('.');
        if (parts.length !== 3) {
          return res.status(400).json({ success: false, message: 'Invalid ID token format' });
        }
        
        // Decode the payload (base64url decode)
        const payloadPart = parts[1];
        const decoded = Buffer.from(payloadPart.replace(/-/g, '+').replace(/_/g, '/'), 'base64').toString('utf-8');
        payload = JSON.parse(decoded);
        
        // Validate that it's a Google token (has required fields)
        if (!payload.email || !payload.sub) {
          return res.status(400).json({ success: false, message: 'Invalid Google token: missing required fields' });
        }
      }
    } catch (error) {
      console.error('Error decoding Google token:', error);
      return res.status(400).json({ success: false, message: 'Invalid or expired Google token' });
    }

    if (!payload || !payload.email) {
      return res.status(400).json({ success: false, message: 'Invalid Google token: email not found' });
    }

    // Check if user exists (by email or googleId)
    let user = await User.findOne({ 
      $or: [
        { email: payload.email },
        { googleId: payload.sub }
      ]
    });

    if (user) {
      // Update googleId if not set
      if (!user.googleId && payload.sub) {
        user.googleId = payload.sub;
        await user.save();
      }
      
      // If user already has verified phone number, log them in directly
      // Only require phone verification if phone is missing or not verified
      if (user.phone && user.isPhoneVerified) {
        // User already has verified phone - log in directly
        const token = generateToken(user._id);
        
        return res.status(200).json({
          success: true,
          requiresOTP: false,
          token,
          user: {
            id: user._id,
            name: user.name,
            email: user.email,
            phone: user.phone
          }
        });
      }
      
      // User exists but phone is missing or not verified - require phone verification
      const sessionId = crypto.randomBytes(32).toString('hex');
      
      await Session.create({
        sessionId,
        userData: {
          name: user.name,
          email: user.email,
          phone: user.phone || '', // Use existing phone if available
          googleId: payload.sub,
          userId: user._id // Store user ID so we can update existing user
        },
        existingUser: true // Flag to indicate this is an existing user
      });

      return res.status(200).json({
        success: true,
        requiresOTP: true,
        sessionId,
        message: 'Please verify your phone number to continue'
      });
    }

    // New user, need phone verification
    const sessionId = crypto.randomBytes(32).toString('hex');
    
    await Session.create({
      sessionId,
      userData: {
        name: payload.name || payload.given_name || 'Google User',
        email: payload.email,
        googleId: payload.sub
      }
    });

    res.status(200).json({
      success: true,
      requiresOTP: true,
      sessionId,
      message: 'Please provide phone number for verification'
    });
  } catch (error) {
    next(error);
  }
});

// POST /api/auth/google-oauth
// Exchange OAuth authorization code for ID token
router.post('/google-oauth', async (req, res, next) => {
  try {
    const { code, redirectUri, clientId, clientSecret } = req.body;

    if (!code || !redirectUri) {
      return res.status(400).json({ success: false, message: 'Authorization code and redirect URI required' });
    }

    // Use extension OAuth credentials if available, otherwise fall back to main credentials
    // This allows supporting multiple OAuth clients (website vs extension)
    const oauthClientId = process.env.GOOGLE_EXTENSION_CLIENT_ID || process.env.GOOGLE_CLIENT_ID;
    const oauthClientSecret = process.env.GOOGLE_EXTENSION_CLIENT_SECRET || process.env.GOOGLE_CLIENT_SECRET;

    if (!oauthClientId || !oauthClientSecret) {
      return res.status(500).json({ 
        success: false, 
        message: 'Google OAuth credentials not configured. Please provide clientId and clientSecret in request or set GOOGLE_CLIENT_ID and GOOGLE_CLIENT_SECRET in environment variables.' 
      });
    }

    // Exchange authorization code for tokens
    try {
      const { OAuth2Client } = require('google-auth-library');
      const client = new OAuth2Client(
        oauthClientId,
        oauthClientSecret,
        redirectUri
      );

      const { tokens } = await client.getToken(code);
      
      if (tokens.id_token) {
        return res.status(200).json({
          success: true,
          idToken: tokens.id_token
        });
      } else {
        return res.status(400).json({ success: false, message: 'ID token not received from Google' });
      }
    } catch (googleError) {
      console.error('Error exchanging OAuth code:', googleError);
      // Fallback: try to get ID token from access token
      // This is a workaround if google-auth-library is not available
      return res.status(500).json({ 
        success: false, 
        message: 'Failed to exchange authorization code. Please ensure google-auth-library is installed.' 
      });
    }
  } catch (error) {
    next(error);
  }
});

// POST /api/auth/verify-google-otp
router.post('/verify-google-otp', async (req, res, next) => {
  try {
    const { sessionId, phone, otp } = req.body;

    if (!sessionId || !phone) {
      return res.status(400).json({ success: false, message: 'Session ID and phone number required' });
    }

    const phoneValidation = validatePhone(phone);
    if (!phoneValidation.valid) {
      return res.status(400).json({ success: false, message: phoneValidation.message });
    }

    const session = await Session.findOne({ sessionId });
    if (!session) {
      return res.status(404).json({ success: false, message: 'Session not found or expired' });
    }

    // If no OTP sent yet or no OTP provided in request, send verification code via Twilio Verify
    if (!otp || otp.trim() === '') {
      // Update phone in session userData
      session.userData.phone = phone;
      // Note: With Twilio Verify, we don't store OTP in session
      if (!session.mobileOTP) {
        session.mobileOTP = {
          verified: false,
          attempts: 0
        };
      }
      // Mark session as modified to ensure phone is saved
      session.markModified('userData');
      await session.save();
      
      // Send verification code via Twilio Verify
      const smsResult = await sendOTPSMS(phone);
      
      if (!smsResult.success) {
        return res.status(500).json({
          success: false,
          message: 'Failed to send verification code. Please try again.',
          error: process.env.NODE_ENV === 'development' ? smsResult.error : undefined
        });
      }

      return res.status(200).json({
        success: true,
        message: 'Verification code sent to phone'
      });
    }

    // Verify OTP using Twilio Verify API
    const twilioVerification = await verifyOTPSMS(phone, otp);
    
    if (!twilioVerification.success) {
      return res.status(400).json({ 
        success: false, 
        message: twilioVerification.error || 'Failed to verify code' 
      });
    }
    
    if (!twilioVerification.valid) {
      return res.status(400).json({ 
        success: false, 
        message: 'Invalid verification code. Please try again.' 
      });
    }

    // Check if this is an existing user (from existingUser flag or userId in session)
    // ALWAYS check by email first to prevent duplicate accounts
    let user;
    const existingUserByEmail = await User.findOne({ email: session.userData.email });
    
    if (existingUserByEmail) {
      // Email already exists - update existing user (don't create duplicate)
      console.log('‚úÖ Found existing user by email:', existingUserByEmail.email);
      user = existingUserByEmail;
      user.phone = phone; // Use the phone from request, not session
      user.isPhoneVerified = true;
      if (session.userData.googleId && !user.googleId) {
        user.googleId = session.userData.googleId;
      }
      await user.save();
    } else if (session.existingUser && session.userData.userId) {
      // Session indicates existing user with userId
      user = await User.findById(session.userData.userId);
      if (user) {
        console.log('‚úÖ Found existing user by userId:', user.email);
        user.phone = phone; // Use the phone from request
        user.isPhoneVerified = true;
        if (session.userData.googleId && !user.googleId) {
          user.googleId = session.userData.googleId;
        }
        await user.save();
      } else {
        // User ID in session but user not found - create new user
        console.log('‚ö†Ô∏è User ID in session but user not found, creating new user');
        user = await User.create({
          name: session.userData.name,
          email: session.userData.email,
          phone: phone,
          googleId: session.userData.googleId,
          password: crypto.randomBytes(32).toString('hex'), // Random password for Google users
          isEmailVerified: true,
          isPhoneVerified: true
        });
      }
    } else {
      // New user - create account
      console.log('‚úÖ Creating new user:', session.userData.email);
      user = await User.create({
        name: session.userData.name,
        email: session.userData.email,
        phone: phone,
        googleId: session.userData.googleId,
        password: crypto.randomBytes(32).toString('hex'), // Random password for Google users
        isEmailVerified: true,
        isPhoneVerified: true
      });
    }

    // Delete session
    await Session.deleteOne({ sessionId });

    // Generate token
    const token = generateToken(user._id);

    res.status(201).json({
      success: true,
      token,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        phone: user.phone
      }
    });
  } catch (error) {
    next(error);
  }
});

// GET /api/auth/me (protected route example)
router.get('/me', protect, async (req, res) => {
  res.status(200).json({
    success: true,
    user: {
      id: req.user._id,
      name: req.user.name,
      email: req.user.email,
      phone: req.user.phone
    }
  });
});

// PUT /api/auth/me - Update user profile
router.put('/me', protect, async (req, res, next) => {
  try {
    const { name, email, phone } = req.body;
    const user = req.user;

    // Validate inputs
    if (name !== undefined) {
      if (!name || name.trim().length < 2) {
        return res.status(400).json({ success: false, message: 'Name must be at least 2 characters' });
      }
      if (name.length > 100) {
        return res.status(400).json({ success: false, message: 'Name cannot exceed 100 characters' });
      }
      user.name = name.trim();
    }

    if (email !== undefined) {
      const emailValidation = validateEmail(email);
      if (!emailValidation.valid) {
        return res.status(400).json({ success: false, message: emailValidation.message });
      }
      // Check if email is already taken by another user
      const existingUser = await User.findOne({ email, _id: { $ne: user._id } });
      if (existingUser) {
        return res.status(400).json({ success: false, message: 'Email already in use' });
      }
      user.email = email.toLowerCase().trim();
    }

    if (phone !== undefined) {
      if (phone) {
        const phoneValidation = validatePhone(phone);
        if (!phoneValidation.valid) {
          return res.status(400).json({ success: false, message: phoneValidation.message });
        }
        user.phone = phone.trim();
      } else {
        // Allow clearing phone number
        user.phone = phone;
      }
    }

    await user.save();

    res.status(200).json({
      success: true,
      user: {
        id: user._id,
        name: user.name,
        email: user.email,
        phone: user.phone
      }
    });
  } catch (error) {
    next(error);
  }
});

// POST /api/auth/logout
// Clear any server-side session data and cookies
// Public endpoint - no auth required (allows logout even if token is invalid)
router.post('/logout', async (req, res) => {
  try {
    // Clear any cookies if they exist
    res.clearCookie('auth_token', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      path: '/'
    });
    res.clearCookie('token', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      path: '/'
    });
    res.clearCookie('session', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      path: '/'
    });
    
    res.status(200).json({
      success: true,
      message: 'Logged out successfully'
    });
  } catch (error) {
    res.status(200).json({
      success: true,
      message: 'Logged out successfully'
    });
  }
});

// DELETE /api/auth/account
// Delete user account and all associated data
// Requires authentication
router.delete('/account', protect, async (req, res, next) => {
  try {
    const userId = req.user._id;

    // Delete all sessions for this user
    try {
      const Session = require('../models/Session');
      await Session.deleteMany({ userId });
      console.log(`üóëÔ∏è Deleted sessions for user ${userId}`);
    } catch (sessionError) {
      console.error('Error deleting sessions:', sessionError);
      // Continue even if session deletion fails
    }

    // Delete all logs for this user
    try {
      const Log = require('../models/Log');
      const deletedLogs = await Log.deleteMany({ userId });
      console.log(`üóëÔ∏è Deleted ${deletedLogs.deletedCount} logs for user ${userId}`);
    } catch (logError) {
      console.error('Error deleting logs:', logError);
      // Continue even if log deletion fails
    }

    // Delete the user account
    await User.findByIdAndDelete(userId);
    console.log(`üóëÔ∏è Deleted user account ${userId}`);

    // Clear cookies
    res.clearCookie('auth_token', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      path: '/'
    });
    res.clearCookie('token', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      path: '/'
    });
    res.clearCookie('session', {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'strict',
      path: '/'
    });

    res.status(200).json({
      success: true,
      message: 'Account deleted successfully'
    });
  } catch (error) {
    console.error('‚ùå Error deleting account:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to delete account',
      error: error.message
    });
  }
});

module.exports = router;